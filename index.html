<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Operators Map — resilient</title>
<style>
  html, body {height:100%; margin:0;}
  #map {position:absolute; inset:0; background:#f4f4f4;}
  .status-badge{
    position:absolute; top:8px; right:8px; z-index:10000;
    background:rgba(0,0,0,.8); color:#fff; padding:6px 10px; border-radius:12px;
    font:500 13px/1.2 system-ui,-apple-system,Segoe UI,Roboto,sans-serif; backdrop-filter: blur(3px);
  }
  .filters-toggle{
    position:absolute; top:8px; left:8px; z-index:10001;
    background:#fff; border:1px solid #ddd; border-radius:10px; padding:8px 10px;
    font:600 13px system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
    box-shadow:0 2px 8px rgba(0,0,0,.12); cursor:pointer;
  }
  aside#filters{
    position:absolute; top:52px; left:8px; z-index:1000;
    width:280px; max-width:calc(100vw - 16px); max-height:calc(100vh - 60px);
    overflow:auto; background:#fff; border:1px solid #ddd; border-radius:14px;
    box-shadow:0 6px 24px rgba(0,0,0,.15); padding:10px; font:14px/1.4 system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
  }
  #filters h3{margin:4px 6px 8px; font-size:14px;}
  #filters .muted{color:#666; font-size:12px; margin-left:6px;}
  #filters .search{margin:6px;}
  #filters .search input{width:100%; padding:6px 8px; border:1px solid #ddd; border-radius:8px;}
  #opsList{list-style:none; margin:8px 6px 10px; padding:0;}
  #opsList li{display:flex; align-items:center; gap:8px; padding:6px 0;}
  .swatch{width:14px; height:14px; border-radius:50%; border:1px solid rgba(0,0,0,.2); flex:0 0 14px;}
  .count{margin-left:auto; color:#888; font-size:12px;}
  @media (max-width:768px){
    aside#filters{ transform:translateX(-110%); transition:transform .25s ease; }
    aside#filters.open{ transform:translateX(0); }
  }
  noscript, .fatal {
    position:absolute; inset:auto 8px 8px 8px; z-index:10002;
    background:#fff; border:1px solid #ddd; border-radius:12px; padding:10px;
    font:14px system-ui,-apple-system,Segoe UI,Roboto,sans-serif; box-shadow:0 2px 8px rgba(0,0,0,.12);
  }
</style>
</head>
<body>
  <div id="map"></div>
  <div class="status-badge" id="statusBadge">Старт…</div>
  <button class="filters-toggle" id="filtersToggle">Фильтры</button>
  <aside id="filters" aria-label="Фильтры по операторам">
    <h3>Операторы <span class="muted" id="operatorsCount">0</span></h3>
    <div class="search"><input id="opSearch" placeholder="Поиск оператора…"/></div>
    <ul id="opsList"></ul>
  </aside>
  <noscript>Нужен JavaScript. Откройте страницу во внешнем браузере.</noscript>

<script>
(async () => {
  // ---------- UI ----------
  const badge = document.getElementById('statusBadge');
  const setBadge = (msg) => { if (badge) badge.textContent = msg; };
  const fatal = (msg) => {
    setBadge('Ошибка');
    const d = document.createElement('div');
    d.className = 'fatal';
    d.innerHTML = '<b>Критическая ошибка</b><br>' + msg + '<br><small>Откройте во внешнем браузере, если это Telegram</small>';
    document.body.appendChild(d);
  };
  window.addEventListener('error', e => setBadge('Ошибка: ' + (e?.message || 'скрипт')));

  // ---------- Multi-CDN loader ----------
  async function loadScriptChain(urls){ for (let i=0;i<urls.length;i++){ try{
      await new Promise((res, rej)=>{ const s=document.createElement('script'); s.src=urls[i]; s.async=true; s.onload=res; s.onerror=()=>rej(new Error(urls[i])); document.head.appendChild(s);});
      return;
  }catch(e){ console.warn('Script fail:', e.message); } }
  throw new Error('Не удалось загрузить JS: '+urls.join(' | ')); }

  async function loadStyleChain(urls){ for (let i=0;i<urls.length;i++){ try{
      await new Promise((res, rej)=>{ const l=document.createElement('link'); l.rel='stylesheet'; l.href=urls[i]; l.onload=res; l.onerror=()=>rej(new Error(urls[i])); document.head.appendChild(l);});
      return;
  }catch(e){ console.warn('CSS fail:', e.message); } }
  throw new Error('Не удалось загрузить CSS: '+urls.join(' | ')); }

  // ---------- Load libs (Leaflet + Papa) ----------
  setBadge('Грузим библиотеки…');
  await loadStyleChain([
    'https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.css',
    'https://unpkg.com/leaflet@1.9.4/dist/leaflet.css',
    'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.css'
  ]);
  await loadScriptChain([
    'https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.js',
    'https://unpkg.com/leaflet@1.9.4/dist/leaflet.js',
    'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.js'
  ]);
  await loadScriptChain([
    'https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js',
    'https://unpkg.com/papaparse@5.4.1/papaparse.min.js',
    'https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js'
  ]);

  // ---------- Map init ----------
  const map = L.map('map', { zoomControl: true }).setView([55.75, 37.62], 9);
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    maxZoom: 19, attribution: '&copy; OpenStreetMap'
  }).addTo(map);

  // ---------- Sources ----------
  const POINTS_URL =
    "https://docs.google.com/spreadsheets/d/e/2PACX-1vQ60bXKqgYfT7N7M5Le0ZWLn4r1ybhUxuYwzAg4hjroeMZHUT_omLa4GwahRBfrEzlG8RKLWMhrKiOP/pub?gid=0&single=true&output=csv";
  const OPERATORS_URL =
    "https://docs.google.com/spreadsheets/d/e/2PACX-1vQ60bXKqgYfT7N7M5Le0ZWLn4r1ybhUxuYwzAg4hjroeMZHUT_omLa4GwahRBfrEzlG8RKLWMhrKiOP/pub?gid=304610077&single=true&output=csv";

  const sleep = (ms)=>new Promise(r=>setTimeout(r,ms));
  const addBuster = (u)=>u + (u.includes('?')?'&':'?') + 't=' + Date.now();

  function corsChain(url){
    return [
      addBuster(url),
      'https://r.jina.ai/http/' + url.replace(/^https?:\/\//,''),
      'https://cors.isomorphic-git.org/' + url,
      'https://api.allorigins.win/raw?url=' + encodeURIComponent(url),
    ];
  }

  async function fetchResilient(url){
    const chain = corsChain(url);
    let lastErr=null;
    for (let i=0;i<chain.length;i++){
      const u = chain[i];
      try{
        setBadge(`Загрузка данных ${i+1}/${chain.length}…`);
        const controller = new AbortController();
        const timer = setTimeout(()=>controller.abort(), 15000);
        const res = await fetch(u, {signal: controller.signal, cache:'no-store', credentials:'omit'});
        clearTimeout(timer);
        if (!res.ok) throw new Error('HTTP '+res.status);
        const text = await res.text();
        if (!text || text.length<5) throw new Error('пустой ответ');
        console.info('[OK]', u);
        return text;
      }catch(e){
        lastErr=e;
        console.warn('[FAIL]', u, e.message);
        await sleep(350*(i+1));
      }
    }
    throw lastErr;
  }

  const num = (v)=> typeof v==='string' ? Number(v.replace(',', '.').trim()) : Number(v);
  const norm = (s)=> (s ?? '').toString().trim();
  function detectColumn(keys, cands){ const lower=keys.map(k=>k.toLowerCase()); for (const c of cands){ const i=lower.indexOf(c.toLowerCase()); if(i!==-1) return keys[i]; } return null; }

  // --- parse coords from single cell (e.g., "55.7, 37.6" or "POINT(37.6 55.7)") ---
  function parseCoordsFromCell(val) {
    if (val == null) return null;
    const s = String(val).trim();
    if (!s) return null;

    let m = s.match(/POINT\s*\(\s*(-?\d+(?:[.,]\d+)?)\s+(-?\d+(?:[.,]\d+)?)\s*\)/i);
    if (m) {
      const lon = Number(m[1].replace(',', '.'));
      const lat = Number(m[2].replace(',', '.'));
      return (isFinite(lat) && isFinite(lon)) ? { lat, lng: lon } : null;
    }

    m = s.match(/(-?\d+(?:[.,]\d+)?)\s*[,;\s]\s*(-?\d+(?:[.,]\d+)?)/);
    if (m) {
      const a = Number(m[1].replace(',', '.'));
      const b = Number(m[2].replace(',', '.'));
      if (Math.abs(a) <= 90 && Math.abs(b) <= 180) return { lat: a, lng: b };
      if (Math.abs(b) <= 90 && Math.abs(a) <= 180) return { lat: b, lng: a };
    }
    return null;
  }

  // --- heuristic guessing of lat/lng columns when headers are weird ---
  function guessLatLngColumns(rows) {
    if (!rows.length) return { latKey: null, lngKey: null, combineKey: null };
    const keys = Object.keys(rows[0] || {});
    const combinedKey = keys.find(k => /коорд|coord|point/i.test(k));
    if (combinedKey) return { latKey: null, lngKey: null, combineKey: combinedKey };

    const numericKeys = keys.filter(k => {
      let hits = 0, ok = 0;
      for (let i = 0; i < Math.min(rows.length, 200); i++) {
        const v = rows[i][k];
        if (v == null || v === '') continue;
        hits++;
        const n = Number(String(v).replace(',', '.'));
        if (isFinite(n)) ok++;
      }
      return hits && ok / hits > 0.9;
    });

    function scoreKey(k) {
      const arr = [];
      for (let i = 0; i < Math.min(rows.length, 1000); i++) {
        const v = rows[i][k];
        if (v == null || v === '') continue;
        const n = Number(String(v).replace(',', '.'));
        if (isFinite(n)) arr.push(n);
      }
      if (arr.length < 5) return { inLat: 0, inLng: 0, mean: 0 };
      const mean = arr.reduce((a,b)=>a+b,0)/arr.length;
      const inLat = arr.filter(n => Math.abs(n) <= 90).length / arr.length;
      const inLng = arr.filter(n => Math.abs(n) <= 180).length / arr.length;
      return { inLat, inLng, mean };
    }

    const scored = numericKeys.map(k => ({ k, ...scoreKey(k) }));
    const latCand = scored.filter(s => s.inLat > 0.95).sort((a,b)=>Math.abs(45-b.mean)-Math.abs(45-a.mean))[0];
    const lngCand = scored.filter(s => s.inLng > 0.95).sort((a,b)=>Math.abs(90-b.mean)-Math.abs(90-a.mean))[0];

    if (latCand && lngCand && latCand.k !== lngCand.k) {
      return { latKey: latCand.k, lngKey: lngCand.k, combineKey: null };
    }
    return { latKey: null, lngKey: null, combineKey: null };
  }

  // ---------- Load data ----------
  try{
    setBadge('Грузим точки…');
    const pointsCsv = await fetchResilient(POINTS_URL);

    setBadge('Грузим операторов…');
    let opsCsv='', opsOk=true;
    try { opsCsv = await fetchResilient(OPERATORS_URL); }
    catch(e){ opsOk=false; console.warn('Справочник операторов недоступен:', e.message); }

    const points = Papa.parse(pointsCsv, {header:true, skipEmptyLines:true, transformHeader:h=>(h??'').toString().trim()}).data || [];
    const ops    = opsOk ? (Papa.parse(opsCsv, {header:true, skipEmptyLines:true, transformHeader:h=>(h??'').toString().trim()}).data || []) : [];

    if (!points.length) return fatal('CSV точек пуст или не распознан.');

    // --- detect/guess columns ---
    const pointKeys = Object.keys(points[0] || {});
    let latKey = detectColumn(pointKeys, ['lat','latitude','широта','y','Lat','Широта','LAT']);
    let lngKey = detectColumn(pointKeys, ['lng','lon','longitude','долгота','x','Lon','Long','Долгота','LNG']);
    let combineKey = null;

    if (!latKey || !lngKey) {
      const guessed = guessLatLngColumns(points);
      latKey = latKey || guessed.latKey;
      lngKey = lngKey || guessed.lngKey;
      combineKey = guessed.combineKey;
    }

    if (!latKey && !lngKey && !combineKey) {
      return fatal('Не найдены колонки lat/lng и не удалось угадать. Проверьте наличие координат в CSV.');
    }

    const operatorKey = detectColumn(pointKeys, ['operator','оператор','отв.пользователь','Оператор']);
    const nameKey     = detectColumn(pointKeys, ['name','название','локация','Location','Адрес']);

    // --- operator colors ---
    const opKeys = Object.keys(ops[0]||{});
    const opNameKey  = detectColumn(opKeys, ['operator','оператор','name','имя','ФИО']);
    const opColorKey = detectColumn(opKeys, ['color','цвет','hex','код']);

    const palette=["#e6194B","#3cb44b","#ffe119","#4363d8","#f58231","#911eb4","#46f0f0","#f032e6",
                   "#bcf60c","#fabebe","#008080","#e6beff","#9A6324","#fffac8","#800000","#aaffc3",
                   "#808000","#ffd8b1","#000075","#808080","#000000"];
    let pi=0; const nextColor=()=>palette[(pi++)%palette.length];

    const operatorColors = new Map();
    if (opsOk && ops.length && opNameKey){
      for (const row of ops){
        const name=norm(row[opNameKey]); if(!name) continue;
        const color=opColorKey?norm(row[opColorKey]):'';
        operatorColors.set(name, color || nextColor());
      }
    }

    // --- draw markers ---
    const layersByOperator = new Map();
    const countsByOperator = new Map();
    const all = [];
    function layerFor(opName){
      if(!layersByOperator.has(opName)) layersByOperator.set(opName, L.layerGroup().addTo(map));
      return layersByOperator.get(opName);
    }

    let ok=0, bad=0;
    for (const r of points){
      let lat, lng;
      if (combineKey) {
        const pair = parseCoordsFromCell(r[combineKey]);
        if (pair) { lat = pair.lat; lng = pair.lng; }
      } else {
        lat = num(r[latKey]); lng = num(r[lngKey]);
      }
      if(!Number.isFinite(lat)||!Number.isFinite(lng)){ bad++; continue; }

      const op=norm(r[operatorKey])||'Без оператора';
      const title=norm(r[nameKey])||`${lat.toFixed(5)}, ${lng.toFixed(5)}`;

      if(!operatorColors.has(op)) operatorColors.set(op, nextColor());
      const color=operatorColors.get(op);

      const m=L.circleMarker([lat,lng], {radius:7, weight:2, opacity:1, color:'#222', fillColor:color, fillOpacity:.85})
        .bindPopup(`<b>${title}</b><br>${op}`);
      layerFor(op).addLayer(m); all.push(m);
      countsByOperator.set(op, (countsByOperator.get(op)||0)+1);
      ok++;
    }

    if (all.length){ const g=L.featureGroup(all); map.fitBounds(g.getBounds().pad(0.2)); }

    const uniqueOps=[...countsByOperator.keys()].sort((a,b)=>(countsByOperator.get(b)||0)-(countsByOperator.get(a)||0));
    setBadge(`${uniqueOps.length} операторов • ${ok} точек${bad?` • пропусков: ${bad}`:''}${opsOk?'':' • справочник не загрузился'}`);

    // --- filters UI ---
    const opsListEl=document.getElementById('opsList');
    const operatorsCountEl=document.getElementById('operatorsCount');
    operatorsCountEl.textContent=uniqueOps.length;
    for (const op of uniqueOps){
      const color=operatorColors.get(op)||'#999';
      const count=countsByOperator.get(op)||0;
      const li=document.createElement('li');
      li.innerHTML=`
        <input type="checkbox" id="op_${btoa(op)}" checked />
        <span class="swatch" style="background:${color}"></span>
        <label for="op_${btoa(op)}">${op}</label>
        <span class="count">${count}</span>`;
      const cb=li.querySelector('input');
      cb.addEventListener('change',()=>{ const layer=layersByOperator.get(op); if(!layer)return; cb.checked?layer.addTo(map):map.removeLayer(layer); });
      opsListEl.appendChild(li);
    }
    document.getElementById('opSearch').addEventListener('input', (e)=>{
      const q=e.target.value.toLowerCase().trim();
      for (const li of opsListEl.querySelectorAll('li')){
        const label=li.querySelector('label')?.textContent?.toLowerCase()||'';
        li.style.display=label.includes(q)?'':'none';
      }
    });

  }catch(e){
    console.error(e);
    fatal('Не удалось инициализировать: ' + (e?.message||e));
  }

  // mobile panel toggle
  const filters=document.getElementById('filters');
  document.getElementById('filtersToggle').addEventListener('click', ()=>filters.classList.toggle('open'));
})();
</script>
</body>
</html>
